# 实现一个简单的锁

```1. 自旋```

    package lock;

    public class ZhangzqLock {

        private volatile int status = 0;

        public void lock() {
            while (!compareAndSet(0, 1)) {
                
            }
        }

        public void unlock() {
            this.status = 0;
        }

        private boolean compareAndSet(int a, int b) {
            if (a == 0 && b == 1 && status == 0) {
                status = 1;
                return true;
            } else {
                return false;
            }
        }

    }

    此处while循环，白白让线程浪费cpu

```2.yield+自旋```

将lock方法换成

    public void lock() {
            while (!compareAndSet(0, 1)) {
                // 为了性能，不让cpu白白飙高，此处加上 yield方法，让出cpu
                Thread.currentThread().yield();
                // 此处为何不用 wait() 因为wait必须要跟sync关键字一起使用，而且wait也不是来阻塞线程的，最重要的是来进行线程之间的通信的
            }
        }

    此处在两个线程执行的时候有用，线程多了之后，就没用了，因为yield让出cpu后可能下一个还是它执行，最重要的是同一时间只有一个线程让出cpu，如果有100 个线程，那也还是有 99个在飙升cpu


```park+自旋```

    package lock;

    import java.util.Iterator;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import java.util.concurrent.locks.LockSupport;

    public class ZLockByPark {

        private volatile int status = 0;

        public ConcurrentLinkedQueue<Thread> queue = new ConcurrentLinkedQueue<>();

        public void lock() {
            while (!compareAndSet(0, 1)) {
                // 如果开始循环了，那就让出cpu，阻塞线程，此处使用 park
                park();
            }
        }

        private void park() {
            // 然后将该线程添加进队列
            queue.add(Thread.currentThread());
            // 对线程进行阻塞
            LockSupport.park();
        }

        public void unlock(){
            this.status = 0;
            // 停止阻塞
            LockSupport.unpark(queue.poll());
        }

        private synchronized boolean compareAndSet(int a, int b) {
            if (a == 0 && b == 1 && status == 0) {
                status = 1;
                return true;
            } else {
                return false;
            }
        }

    }

    cpu不飙升了，ReentrantLock 就是这个思路，但是代码绝对比这个复杂n多倍



### 自旋锁

    自己循环的锁，就像上文中的 while循环

    