# 锁

## 读锁与写锁

* 读锁，共享锁，shared locks ，S 锁
* 写锁，排他锁，Exclusive Locks，X 锁
* select 不加锁 ， ***因为不加锁，所以不会被 读写锁排斥***

读锁：对某一行数据进行加读锁，那么其他的操作就不能更新这条数据，但是可以读

写锁：对某一行数据进行加写锁，那么其他的操作就不能更新，也不能取读取

|      | S锁    | X锁  |
| ---- | ------ | ---- |
| S锁  | 不冲突 | 冲突 |
| X锁  | 冲突   | 冲突 |

### 读操作

对于普通 select 语句，Innodb 不会加任何锁

#### select * from table where 1=1 lock in share mode;

将查找到的数据加上 S 锁，允许其他事务继续获取这些记录的S锁，不能获取这些记录的 X锁(冲突，会阻塞，排队)



使用场景：读出数据后，其他事务不能修改，但是自己也不一定能修改，因为别的事务也可以使用 **select ... lock in share mode** 加S(读)锁。

#### select ... for update

将查找到的数据加 X 锁(写锁)，不允许其他的事务获取这些记录的 S锁和 X锁



使用场景：取出数据之后，其他事务不能写，也不能加读锁，那么就导致只有自己可以修改数据。



### 写操作

* delete ： 删除一条数据，先对记录加 X 锁，然后再执行删除操作。
* insert ： 插入一条数据，先会加 **隐式锁** 来保护新插入的这条记录，在本事务提交之前不被别的事务访问到。
* update
  * 如果被更新的列，修改前后没有导致存储空间的变化，那么会先给记录加 X 锁，再直接对记录进行修改
  * 如果被更新的列，修改前后导致存储空间发生了变化，那么会先给记录加 X 锁，然后删除该记录，然后再Insert 一条新记录。

> 隐式锁：一个事务插入一条记录之后，还未提交，这条记录会保存当前事务id，而其他事务如果想来对这个记录来加锁时会发生事务id不对应，这是会产生X锁，所以相当于再插入一条记录时，隐式的给这条记录加了一把隐式X锁。



### 行锁和表锁

#### 行锁

* LOCK_REC_NOT_GAP ：单个行记录上的锁
* LOCK_GAP：间隙锁，锁定一个范围，但不包括记录本身，GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读现象。
* LOCK_ORDINARY：锁定一个范围，并且包括记录本身，对于的行查询，都是采用该方法，主要目的是解决幻读的问题。





